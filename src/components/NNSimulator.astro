
<section class="nn-container">
	<h2>🌱 Simulador de Red Neuronal para Riego Inteligente</h2>

	<div class="intro">
		<p><strong>¿Qué hace este simulador?</strong></p>
		<p>Este sistema aprende a decidir cuándo regar basándose en tres factores: humedad del suelo, temperatura y probabilidad de lluvia. Los "pesos" controlan cuánta importancia le da la red neuronal a cada sensor. ¡Experimenta y observa cómo aprende!</p>
	</div>

	<div class="grid">
		<!-- ENTRADAS -->
		<div class="card">
			<h4>🌤️ Condiciones Actuales del Cultivo</h4>
			<label>
				Humedad del Suelo (%)
				<span class="value-display" id="x_h_v">35%</span>
			</label>
			<input id="x_h" type="range" min="0" max="100" value="35" />
			<small style="color: #777;">💡 Si baja de 35% → Necesita riego urgente</small>

			<label>
				Temperatura Ambiente (°C)
				<span class="value-display" id="x_t_v">28°C</span>
			</label>
			<input id="x_t" type="range" min="0" max="45" value="28" />
			<small style="color: #777;">💡 A mayor temperatura → Más evaporación</small>

			<label>
				Probabilidad de Lluvia (%)
				<span class="value-display" id="x_r_v">20%</span>
			</label>
			<input id="x_r" type="range" min="0" max="100" value="20" />
			<small style="color: #777;">💡 Si lloverá pronto → No regar</small>
		</div>

		<!-- PESOS -->
		<div class="card">
			<h4>⚙️ Importancia de Cada Sensor (Pesos)</h4>
			<p style="font-size: 0.9rem; color: #666; margin-bottom: 15px;">
				Estos valores controlan <strong>cuánto influye</strong> cada sensor en la decisión. Al cambiarlos y presionar "Entrenar", la red aprenderá con esa configuración.
			</p>
			<label>
				Peso: Humedad del Suelo
				<span class="weight-display" id="w_h_v">0.60</span>
			</label>
			<input id="w_h" type="range" min="0" max="100" value="60" />
			<small style="color: #777;">↑ Más peso = Más prioridad a la humedad</small>

			<label>
				Peso: Temperatura
				<span class="weight-display" id="w_t_v">0.50</span>
			</label>
			<input id="w_t" type="range" min="0" max="100" value="50" />
			<small style="color: #777;">↑ Más peso = Más sensible al calor</small>

			<label>
				Peso: Lluvia
				<span class="weight-display" id="w_r_v">0.40</span>
			</label>
			<input id="w_r" type="range" min="0" max="100" value="40" />
			<small style="color: #777;">↑ Más peso = Más considera el pronóstico</small>
		</div>

		<!-- CONTROLES -->
		<div class="card">
			<h4>🎛️ Control del Sistema</h4>
			<div class="buttons">
				<button id="train" class="btn-train">📚 Entrenar Red</button>
				<button id="predict" class="btn-predict">🔮 Predecir Ahora</button>
				<button id="rtToggle" class="btn-realtime">⏯️ Simulación: OFF</button>
				<button id="reset" class="btn-reset">🔄 Reiniciar Todo</button>
			</div>

			<div class="result">
				<strong>📊 Épocas entrenadas:</strong> <span id="epochs">0</span><br/>
				<strong>📉 Error (pérdida):</strong> <span id="loss">—</span><br/>
			<strong>🧮 Salida de la red:</strong> <span id="nnOutput">—</span><br/>
			<strong>⚖️ Puntaje ponderado:</strong> <span id="score">—</span><br/>
			<strong>🔁 Probabilidad combinada:</strong> <span id="combined">—</span><br/>
			</div>

			<div id="decisionBox" class="decision-box" style="display: none;">
				<span id="decision">—</span>
			</div>
		</div>
	</div>

	<!-- GRÁFICO DE HISTÓRICO -->
	<div class="chart-container">
		<h4>📈 Histórico de Decisiones (Últimas 10 lecturas)</h4>
		<canvas id="historyChart"></canvas>
	</div>

	<!-- TABLA DE HISTÓRICO -->
	<div class="chart-container">
		<h4>📋 Registro Detallado de Datos</h4>
		<table id="historyTable">
			<thead>
				<tr>
					<th>#</th>
					<th>Humedad (%)</th>
					<th>Temp. (°C)</th>
					<th>Lluvia (%)</th>
					<th>Salida NN</th>
					<th>Puntaje</th>
					<th>Decisión</th>
				</tr>
			</thead>
			<tbody id="historyBody">
				<tr><td colspan="7" style="text-align: center; color: #999;">No hay datos aún. Presiona "Predecir" o activa simulación.</td></tr>
			</tbody>
		</table>
	</div>

	<!-- EXPLICACIÓN -->
	<div class="info-box">
		<strong>🔍 ¿Qué sucede cuando cambias los pesos?</strong>
		<ul>
			<li><strong>Peso de Humedad ALTO (0.8-1.0):</strong> La red priorizará mantener humedad alta. Regará aunque temperatura sea baja o vaya a llover.</li>
			<li><strong>Peso de Temperatura ALTO (0.8-1.0):</strong> La red será muy sensible al calor. Regará más frecuentemente en días calurosos.</li>
			<li><strong>Peso de Lluvia ALTO (0.8-1.0):</strong> La red evitará regar si hay pronóstico de lluvia, ahorrando agua.</li>
			<li><strong>Pesos Balanceados (0.5-0.6 todos):</strong> La red considerará todos los factores por igual, tomando decisiones más equilibradas.</li>
		</ul>
		<p style="margin-top: 10px;"><strong>💡 Tip:</strong> Después de cambiar los pesos, presiona "Entrenar Red" para que el sistema aprenda con la nueva configuración. Luego presiona "Predecir" para ver cómo cambia la decisión.</p>
	</div>
</section>

<style>
	.nn-container { max-width: 1200px; margin: 0 auto; padding: 20px; }
	.nn-container h2 { color: #2e7d32; margin-bottom: 10px; }
	.intro { background: #e8f5e9; border-left: 4px solid #2e7d32; padding: 15px; border-radius: 8px; margin-bottom: 20px; }
	.grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px; margin-bottom: 20px; }
	.card { background: white; border: 1px solid #e0e0e0; border-radius: 12px; padding: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
	.card h4 { color: #333; margin-bottom: 15px; font-size: 1.1em; }
	label { display: block; margin: 15px 0 5px; color: #555; font-weight: 500; }
	input[type="range"] { width: 100%; cursor: pointer; }
	button { padding: 10px 20px; border-radius: 8px; border: none; cursor: pointer; font-weight: 600; transition: all 0.3s; }
	button:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
	.btn-train { background: #2e7d32; color: white; }
	.btn-predict { background: #1976d2; color: white; }
	.btn-realtime { background: #f57c00; color: white; }
	.btn-reset { background: #d32f2f; color: white; }
	.buttons { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 15px; }
	.result { margin-top: 15px; padding: 15px; background: #f5f5f5; border-radius: 8px; }
	.result strong { color: #333; }
	.chart-container { background: white; border-radius: 12px; padding: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-top: 20px; }
	canvas { max-height: 300px; }
	.value-display { display: inline-block; background: #e3f2fd; padding: 4px 12px; border-radius: 6px; font-weight: 600; color: #1976d2; margin-left: 10px; }
	.weight-display { display: inline-block; background: #fff3e0; padding: 4px 12px; border-radius: 6px; font-weight: 600; color: #f57c00; margin-left: 10px; }
	.info-box { background: #fff9c4; border-left: 4px solid #fbc02d; padding: 15px; border-radius: 8px; margin-top: 15px; }
	.info-box ul { margin-left: 20px; margin-top: 10px; }
	.info-box li { margin: 8px 0; color: #555; }
	.decision-box { padding: 20px; border-radius: 12px; text-align: center; font-size: 1.3em; font-weight: bold; margin-top: 15px; }
	.decision-regar { background: linear-gradient(135deg, #2e7d32 0%, #66bb6a 100%); color: white; }
	.decision-no-regar { background: linear-gradient(135deg, #757575 0%, #bdbdbd 100%); color: white; }
	table { width: 100%; border-collapse: collapse; margin-top: 15px; }
	th, td { padding: 12px; text-align: left; border-bottom: 1px solid #e0e0e0; }
	th { background: #f5f5f5; font-weight: 600; color: #333; }
	tr:hover { background: #f9f9f9; }
	.badge { display: inline-block; padding: 4px 10px; border-radius: 12px; font-size: 0.85em; font-weight: 600; }
	.badge-regar { background: #c8e6c9; color: #2e7d32; }
	.badge-no-regar { background: #e0e0e0; color: #616161; }
</style>

<script src="https://cdn.jsdelivr.net/npm/chart.js" defer></script>
<script is:inline>
// @ts-nocheck
	window.addEventListener('DOMContentLoaded', () => {
	// ============================================================================
	// FUNCIONES MATEMÁTICAS
	// ============================================================================
	const relu = x => Math.max(0, x);
	const sigmoid = x => 1 / (1 + Math.exp(-x));
	const dsigmoid = y => y * (1 - y);
	const randn = () => (Math.random() * 2 - 1) * 0.1;
	const lr = 0.01;

	// ============================================================================
	// RED NEURONAL
	// ============================================================================
	let W1 = Array.from({ length: 6 }, () => [randn(), randn(), randn()]);
	let b1 = Array.from({ length: 6 }, () => randn());
	let W2 = Array.from({ length: 6 }, () => randn());
	let b2 = randn();
	let totalEpochs = 0;

	// ============================================================================
	// HISTÓRICO
	// ============================================================================
	/** @type {{h:number;t:number;r:number;nn:number;score:number;combined:number;decision:number}[]} */
	let history = [];
	const MAX_HISTORY = 10;

	// ============================================================================
	// ELEMENTOS DOM (con verificación de null)
	// ============================================================================
	const hIn = document.getElementById("x_h");
	const tIn = document.getElementById("x_t");
	const rIn = document.getElementById("x_r");
	const hv = document.getElementById("x_h_v");
	const tv = document.getElementById("x_t_v");
	const rv = document.getElementById("x_r_v");

	const whIn = document.getElementById("w_h");
	const wtIn = document.getElementById("w_t");
	const wrIn = document.getElementById("w_r");
	const whv = document.getElementById("w_h_v");
	const wtv = document.getElementById("w_t_v");
	const wrv = document.getElementById("w_r_v");

	const lossEl = document.getElementById("loss");
	const nnOutputEl = document.getElementById("nnOutput");
	const scoreEl = document.getElementById("score");
	const combinedEl = document.getElementById("combined");
	const decisionEl = document.getElementById("decision");
	const decisionBox = document.getElementById("decisionBox");
	const epochsEl = document.getElementById("epochs");
	const rtBtn = document.getElementById("rtToggle");
	const historyBody = document.getElementById("historyBody");

	// ============================================================================
	// GRÁFICO
	// ============================================================================
	const canvas = document.getElementById('historyChart');
	const ctx = canvas ? canvas.getContext('2d') : null;
	const ChartCtor = window.Chart;
	const chart = new ChartCtor(ctx, {
		type: 'line',
		data: {
			labels: [],
			datasets: [
				{
					label: 'Humedad del Suelo (%)',
					data: [],
					borderColor: '#2e7d32',
					backgroundColor: 'rgba(46, 125, 50, 0.1)',
					tension: 0.4
				},
				{
					label: 'Temperatura (°C)',
					data: [],
					borderColor: '#f57c00',
					backgroundColor: 'rgba(245, 124, 0, 0.1)',
					tension: 0.4
				},
				{
					label: 'Lluvia (%)',
					data: [],
					borderColor: '#00796b',
					backgroundColor: 'rgba(0, 121, 107, 0.1)',
					tension: 0.4
				},
				{
					label: 'Probabilidad combinada (%)',
					data: [],
					borderColor: '#1976d2',
					backgroundColor: 'rgba(25, 118, 210, 0.1)',
					borderWidth: 3,
					tension: 0
				}
			]
		},
		options: {
			responsive: true,
			maintainAspectRatio: true,
			scales: {
				y: { beginAtZero: true, max: 100 }
			},
			plugins: {
				legend: { position: 'top' }
			}
		}
	});

	// ============================================================================
	// ACTUALIZAR DISPLAYS
	// ============================================================================
	function updateDisplays() {
		if (hv) hv.textContent = `${hIn.value}%`;
		if (tv) tv.textContent = `${tIn.value}°C`;
		if (rv) rv.textContent = `${rIn.value}%`;
		if (whv && whIn) whv.textContent = (Number(whIn.value) / 100).toFixed(2);
		if (wtv && wtIn) wtv.textContent = (Number(wtIn.value) / 100).toFixed(2);
		if (wrv && wrIn) wrv.textContent = (Number(wrIn.value) / 100).toFixed(2);
	}

	[hIn, tIn, rIn, whIn, wtIn, wrIn].forEach(el => {
		if (el) el.addEventListener("input", updateDisplays);
	});

	updateDisplays();
	predict();

	// ============================================================================
	// RED HACIA ADELANTE
	// ============================================================================
	/** @param {number[]} x */
	function forward(x) {
		const z1 = W1.map((w, i) => w[0] * x[0] + w[1] * x[1] + w[2] * x[2] + b1[i]);
		const h = z1.map(relu);
		const z2 = h.reduce((s, hi, i) => s + hi * W2[i], b2);
		const y = sigmoid(z2);
		return { h, y };
	}

	// ============================================================================
	// CREAR DATASET SINTÉTICO
	// ============================================================================
	/** @param {number} [n=400] */
	function makeDataset(n = 400) {
		const wh = whIn && whIn.value != null ? Number(whIn.value) / 100 : 0.6;
		const wt = wtIn && wtIn.value != null ? Number(wtIn.value) / 100 : 0.5;
		const wr = wrIn && wrIn.value != null ? Number(wrIn.value) / 100 : 0.4;
		
		const data = [];
		for (let i = 0; i < n; i++) {
			const h = Math.random();
			const t = Math.random();
			const r = Math.random();
			const score = (1 - h) * wh + t * wt + (1 - r) * wr;
			const y = score > 0.6 ? 1 : 0;
			data.push({ x: [h, t, r], t: y });
		}
		return data;
	}

	// ============================================================================
	// ENTRENAMIENTO
	// ============================================================================
	/** @param {{x:number[];t:number}[]} data */
	function trainEpoch(data) {
		let mse = 0;
		for (const { x, t } of data) {
			const { h, y } = forward(x);
			const e = y - t;
			mse += e * e;
			const dz2 = e * dsigmoid(y);
			for (let i = 0; i < 6; i++) {
				W2[i] -= lr * dz2 * h[i];
			}
			b2 -= lr * dz2;
			for (let i = 0; i < 6; i++) {
				const dh = dz2 * W2[i];
				const dz1 = h[i] > 0 ? dh : 0;
				W1[i][0] -= lr * dz1 * x[0];
				W1[i][1] -= lr * dz1 * x[1];
				W1[i][2] -= lr * dz1 * x[2];
				b1[i] -= lr * dz1;
			}
		}
		return mse / data.length;
	}

	// ============================================================================
	// AGREGAR AL HISTÓRICO
	// ============================================================================
	/** @param {number} h @param {number} t @param {number} r @param {number} nn @param {number} score @param {number} combined @param {number} decision */
	function addToHistory(h, t, r, nn, score, combined, decision) {
		history.push({ h, t, r, nn, score, combined, decision });
		if (history.length > MAX_HISTORY) history.shift();
		chart.data.labels = history.map((_, i) => `#${i + 1}`);
		chart.data.datasets[0].data = history.map(d => d.h);
		chart.data.datasets[1].data = history.map(d => d.t);
		chart.data.datasets[2].data = history.map(d => d.r);
		chart.data.datasets[3].data = history.map(d => d.combined * 100);
		chart.update();
		if (historyBody) {
			historyBody.innerHTML = history.map((d, i) => `
				<tr>
					<td>${i + 1}</td>
					<td>${d.h.toFixed(1)}%</td>
					<td>${d.t.toFixed(1)}°C</td>
					<td>${d.r.toFixed(1)}%</td>
					<td>${d.nn.toFixed(3)}</td>
					<td>${d.score.toFixed(3)}</td>
					<td><span class="badge ${d.decision > 0.5 ? 'badge-regar' : 'badge-no-regar'}">${d.decision > 0.5 ? '💧 Regar' : '🌤️ No regar'}</span></td>
				</tr>
			`).reverse().join('');
		}
	}

	// ============================================================================
	// PREDICCIÓN
	// ============================================================================
	function predict() {
		const h = hIn ? Number(hIn.value) : 35;
		const t = tIn ? Number(tIn.value) : 28;
		const r = rIn ? Number(rIn.value) : 20;
		const normalizedH = h / 100;
		const normalizedT = t / 45;
		const normalizedR = r / 100;
		const x = [normalizedH, normalizedT, normalizedR];
		const { y } = forward(x);
		if (nnOutputEl) nnOutputEl.textContent = y.toFixed(3);
		const whVal = whIn && whIn.value != null ? Number(whIn.value) / 100 : 0.6;
		const wtVal = wtIn && wtIn.value != null ? Number(wtIn.value) / 100 : 0.5;
		const wrVal = wrIn && wrIn.value != null ? Number(wrIn.value) / 100 : 0.4;
		const totalWeights = whVal + wtVal + wrVal || 1;
		const weightedScore = ((1 - normalizedH) * whVal + normalizedT * wtVal + (1 - normalizedR) * wrVal) / totalWeights;
		if (scoreEl) scoreEl.textContent = weightedScore.toFixed(3);
		const combinedProb = Math.min(1, Math.max(0, (y + weightedScore) / 2));
		if (combinedEl) combinedEl.textContent = combinedProb.toFixed(3);
		const shouldIrrigate = combinedProb > 0.5;
		if (decisionEl && decisionBox) {
			decisionEl.textContent = shouldIrrigate ? "💧 REGAR ACTIVADO" : "🌤️ NO REGAR (Descanso)";
			decisionBox.className = shouldIrrigate ? "decision-box decision-regar" : "decision-box decision-no-regar";
			decisionBox.style.display = "block";
		}
		addToHistory(h, t, r, y, weightedScore, combinedProb, shouldIrrigate ? 1 : 0);
	}

	// ============================================================================
	// EVENTOS DE BOTONES
	// ============================================================================
	const trainBtn = document.getElementById("train");
	if (trainBtn) {
		trainBtn.addEventListener("click", () => {
			if (lossEl) lossEl.textContent = "Entrenando...";
			const data = makeDataset(400);
			let lastLoss = 0;
			for (let e = 0; e < 300; e++) {
				lastLoss = trainEpoch(data);
			}
			totalEpochs += 300;
			if (lossEl) lossEl.textContent = lastLoss.toFixed(4);
			if (epochsEl) epochsEl.textContent = totalEpochs;
			alert(`✅ Entrenamiento completado!\n\n` +
				`La red ha aprendido con los pesos configurados:\n` +
				`• Humedad: ${whIn ? (whIn.value / 100).toFixed(2) : '0.60'}\n` +
				`• Temperatura: ${wtIn ? (wtIn.value / 100).toFixed(2) : '0.50'}\n` +
				`• Lluvia: ${wrIn ? (wrIn.value / 100).toFixed(2) : '0.40'}\n\n` +
				`Épocas totales: ${totalEpochs}\n` +
				`Error final: ${lastLoss.toFixed(4)}`);
			predict();
		});
	}

	const predictBtn = document.getElementById("predict");
	if (predictBtn) {
		predictBtn.addEventListener("click", predict);
	}

	// ============================================================================
	// SIMULACIÓN EN TIEMPO REAL
	// ============================================================================
	const samples = [
		{ h: 42, t: 26, r: 10 },
		{ h: 38, t: 30, r: 15 },
		{ h: 55, t: 22, r: 80 },
		{ h: 28, t: 33, r: 5 },
		{ h: 47, t: 27, r: 40 },
		{ h: 35, t: 29, r: 20 },
		{ h: 25, t: 35, r: 0 },
		{ h: 65, t: 18, r: 90 }
	];

	let rtTimer = null;
	let sampleIdx = 0;

	if (rtBtn) {
		rtBtn.addEventListener("click", () => {
			if (rtTimer) {
				clearInterval(rtTimer);
				rtTimer = null;
				rtBtn.textContent = "⏯️ Simulación: OFF";
				rtBtn.className = "btn-realtime";
				return;
			}
			rtBtn.textContent = "⏸️ Simulación: ON";
			rtBtn.style.background = "#4caf50";
			applySample(samples[sampleIdx % samples.length]);
			rtTimer = setInterval(() => {
				sampleIdx++;
				applySample(samples[sampleIdx % samples.length]);
			}, 3000);
		});
	}

	/** @param {{h:number;t:number;r:number}} s */
	function applySample(s) {
		if (hIn) hIn.value = s.h;
		if (tIn) tIn.value = s.t;
		if (rIn) rIn.value = s.r;
		updateDisplays();
		predict();
	}

	// ============================================================================
	// REINICIAR
	// ============================================================================
	const resetBtn = document.getElementById("reset");
	if (resetBtn) {
		resetBtn.addEventListener("click", () => {
			if (confirm("¿Reiniciar todo el sistema? Se perderán los datos de entrenamiento e histórico.")) {
				W1 = Array.from({ length: 6 }, () => [randn(), randn(), randn()]);
				b1 = Array.from({ length: 6 }, () => randn());
				W2 = Array.from({ length: 6 }, () => randn());
				b2 = randn();
				totalEpochs = 0;
				history = [];
				if (lossEl) lossEl.textContent = "—";
				if (nnOutputEl) nnOutputEl.textContent = "—";
				if (scoreEl) scoreEl.textContent = "—";
				if (combinedEl) combinedEl.textContent = "—";
				if (epochsEl) epochsEl.textContent = "0";
				if (decisionBox) decisionBox.style.display = "none";
				chart.data.labels = [];
				chart.data.datasets[0].data = [];
				chart.data.datasets[1].data = [];
				chart.data.datasets[2].data = [];
				chart.data.datasets[3].data = [];
				chart.update();
				if (historyBody) {
					historyBody.innerHTML = '<tr><td colspan="7" style="text-align: center; color: #999;">Sistema reiniciado. Presiona "Entrenar" para comenzar.</td></tr>';
				}
				if (rtTimer) {
					clearInterval(rtTimer);
					rtTimer = null;
					if (rtBtn) rtBtn.textContent = "⏯️ Simulación: OFF";
				}
			}
		});
	}
});
</script>
  